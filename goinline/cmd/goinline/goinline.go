package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/build"
	"go/parser"
	"go/printer"
	"go/token"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/sasha-s/go-inline/goinline"
)

func init() {
	flag.StringVar(&opts.pkg, "package", "", "package to use as a blueprint. Something like `github.com/sasha-s/goinline/examples/blueprints/concurrentmap`")
	flag.StringVar(&opts.targetDir, "target-dir", "", "where to put the generated code. Will modify the blueprint (according to package) if empty")
	flag.StringVar(&opts.targetPackageName, "target-package-name", "", "package name for the generated code. Ignored if empty")
	flag.BoolVar(&opts.w, "w", false, "write result to a file instead of stdout")
	flag.BoolVar(&opts.tests, "tests", false, "process tests as well")
}

func main() {
	flag.Parse()
	if opts.pkg == "" {
		oops("-package should not be empty")
	}
	pk, err := build.Default.Import(opts.pkg, "", 0)
	if err != nil {
		log.Fatalln(err.Error())
	}
	if opts.targetDir == "" {
		opts.targetDir = pk.Dir
	}
	if opts.w {
		err := os.MkdirAll(opts.targetDir, 0777)
		if err != nil {
			log.Fatalln(err.Error())
		}
	}
	// Build the inline map.
	im := map[string]goinline.Target{}
	for _, s := range flag.Args() {
		k, v, err := goinline.ParseTarget(s)
		if err != nil {
			oops(err.Error())
		}
		if old, ok := im[k]; ok {
			oops(fmt.Sprintf("Duplicate rewrite rule. Already have `%s:%s`, now: `%s`", k, old, s))
		}
		im[k] = v
	}
	files := pk.GoFiles
	if opts.tests {
		files = append(files, pk.TestGoFiles...)
	}
	for _, f := range files {
		full := filepath.Join(pk.Dir, f)
		target := filepath.Join(opts.targetDir, f)
		abs, err := filepath.Abs(target)
		if err != nil {
			abs = target
		}
		fmt.Fprintf(os.Stderr, "`%s`->`%s`\n", full, abs)
		r, err := os.Open(full)
		if err != nil {
			log.Fatalf("Can not be open `%s` for reading. Error: `%s`\n", full, err)
		}
		defer r.Close()
		var w io.Writer
		if !opts.w {
			w = os.Stdout
		} else {
			if opts.targetDir != pk.Dir {
				if err = canWriteSafely(target); err != nil {
					log.Fatalf("Target file `%s` is not empty and not generated by goinline. Error: %s\n", target, err)
				}
			}
		}

		var fset = token.NewFileSet()
		f, err := parser.ParseFile(fset, full, nil, parser.ParseComments)
		if err != nil {
			log.Fatalln(err)
		}
		err = goinline.Inline(fset, f, im)
		if err != nil {
			oops(err.Error())
		}
		// Change target package name if needed.
		if opts.targetPackageName != "" {
			f.Name = &ast.Ident{Name: opts.targetPackageName}
		}
		if w == nil {
			w, err = os.Create(target)
			if err != nil {
				log.Fatalf("Can not be open `%s` for writing. Error: `%s`\n", target, err)
			}
			defer w.(io.Closer).Close()
			if opts.targetDir != pk.Dir {
				_, err = fmt.Fprintf(w, "%s %s\n\n", string(preamble), strings.Join(os.Args[1:], " "))
				if err != nil {
					log.Fatalln(err)
				}
			}
		}
		err = printer.Fprint(w, fset, f)
		if err != nil {
			log.Fatalln(err)
		}
	}
}

// oops prints the msg, usage and then exits with error code 2.
func oops(msg string) {
	fmt.Fprintln(os.Stderr, msg)
	_, f := filepath.Split(os.Args[0])
	fmt.Fprintf(os.Stderr, "Usage:\n%s ${flags} ${rewrite rules}\n", f)
	fmt.Fprintln(os.Stderr, `Rewrite rules: each rewrite rule is either old->new (will replace old with new), or
old->${imports}::new (will replace old with new, adding imports if needed).
Imports are comma-separated.
`)
	fmt.Fprintln(os.Stderr, "Flags:")
	flag.PrintDefaults()
	os.Exit(2)
}

// canWriteSafely checks whether we can write the file safely.
// It is safe to write if either
// * fn does not exists.
// * fn exists and starts with the preamble (was create using goinline).
func canWriteSafely(fn string) error {
	_, err := os.Stat(fn)
	if os.IsNotExist(err) {
		return nil
	}
	f, err := os.Open(fn)
	if err != nil {
		return err
	}
	defer f.Close()
	buf := make([]byte, len(preamble))
	_, err = io.ReadAtLeast(f, buf, len(buf))
	if err != nil {
		return fmt.Errorf("failed to read %d bytes: `%s`", len(buf), err)
	}
	if !bytes.Equal(buf, preamble) {
		return fmt.Errorf("the preamble does not match. Exptected `%s`, got `%s`", string(preamble), string(buf))
	}
	return nil
}

var opts struct {
	pkg               string
	targetDir         string
	targetPackageName string
	w                 bool
	tests             bool
}

var preamble = []byte("// DO NOT EDIT. Generated with goinline")
